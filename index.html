<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Prueba para tfg</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			b {
				color: black
			}
		</style>
	</head>
	<body>
		
		<div id='container'>
				<div id="hms"></div>
				
				<div id= "puntuacion"></div>
		</div>
		
		<!--<div id="blocker"> 
				
				<div id="instructions">
					<span style="font-size:36px">Click to play</span>
					<br /><br />
					Move: WASD<br/>
					Look: MOUSE or Device Orientation
				</div>
		</div> -->
		
		
			
		<script type="module">

			import * as THREE from '/build/three.module.js';

			import { PointerLockControls } from '/examples/jsm/controls/PointerLockControls.js';
			
			import { DDSLoader } from '/examples/jsm/loaders/DDSLoader.js';
			import { MTLLoader } from '/examples/jsm/loaders/MTLLoader.js';
			import { OBJLoader } from '/examples/jsm/loaders/OBJLoader.js';
			
			import { DeviceOrientationControls } from '/examples/jsm/controls/DeviceOrientationControls.js';
  
			import { StereoEffect } from '/examples/jsm/effects/StereoEffect.js';
			
			import { VRButton } from '/examples/jsm/webxr/VRButton.js';

			var camera, scene, renderer, controls;

			var objects = [];

			var raycaster;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();
			
			var is_mobile= /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
			
			var effect,element,container,cube;
			
			var clock = new THREE.Clock();
			
			var Reloj = new THREE.Clock(false);
			
			var vec = new THREE.Vector3();
			var vecPrueba = new THREE.Vector3();
			
			var UNITWIDTH = 45;                 // Width of a cubes in the maze
			var UNITHEIGHT = 45;                // Height of the cubes in the maze
			
			var totalCubesWide;
			var collidableObjects = []; // An array of collidable objects used later
			
			var mapSize,listener,sound,mesh;
			
			var loader,cubito;
		
			var cosas = [];
			
			var level = 1; //indicador de nivel 
			
			var h = 0;
			var m = 0;
			var s = 0;
			var id;
		
			

			init();
			animate();

			function init() {
				
				
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//document.body.appendChild( renderer.domElement );
				element = renderer.domElement;
				container = document.getElementById('container');
				container.appendChild(element);
				document.body.appendChild( VRButton.createButton( renderer ) );
				renderer.xr.enabled = true;
				
				document.getElementById("hms").innerHTML="00:00:00";
				
				
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 10;
				
				listener = new THREE.AudioListener();
				camera.add(listener);
				

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );
				//scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
				
				

				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );
				
				const rig = new THREE.Object3D();
				rig.add(camera);
				scene.add(rig);
				
				//Controls
				if(is_mobile){
					scene.add(camera);
					
					//effect = new StereoEffect(renderer);
			
					controls = new DeviceOrientationControls(camera);
					controls.connect();
					
					

					/*document.addEventListener( 'click', function () {
						fullscreen();
						instructions.style.display = 'none';
						blocker.style.display = 'none';

					}, false );*/
					
					
					
				} else {
					controls = new PointerLockControls( camera, document.body );
					
					document.addEventListener( 'click', function () {
						
						controls.lock();
						cronometrar();
						fullscreen();

					}, false );
					
					controls.addEventListener( 'lock', function () {

						instructions.style.display = 'none';
						blocker.style.display = 'none';

					} );
					controls.addEventListener( 'unlock', function () {

						blocker.style.display = 'block';
						instructions.style.display = '';
						parar();

					} );
					
					scene.add( controls.getObject() );
				}
				
				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;
							
						case 39: // right
						case 68: // d
							moveRight = true;
							break;

	

					}

				};

				var onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3(), 0, 10 );
				
				sound = new THREE.PositionalAudio( listener );

				// load a sound and set it as the PositionalAudio object's buffer
				var audioLoader = new THREE.AudioLoader();
				audioLoader.load( 'examples/sounds/376737_Skullbeatz___Bad_Cat_Maste.ogg', function( buffer ) {
					sound.setBuffer( buffer );
					sound.setRefDistance( 5);
					sound.setRolloffFactor ( 0.5 );
					sound.setLoop( true );
					sound.play();
				});

				// create an object for the sound to play from
				var sphere = new THREE.SphereBufferGeometry( 10,10,10 );
				var material = new THREE.MeshPhongMaterial( { color: 0xff2200 } );
				mesh = new THREE.Mesh( sphere, material );
				scene.add( mesh );
				mesh.add(sound);
				
				
				// Add the walls(cubes) of the maze
				createMazeCubes();
				// Add ground plane
				createGround();
				// Add perimeter walls that surround the maze
				createPerimWalls();
				
				

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				
				if(is_mobile)
					effect.setSize(width, height);
				
			}
			
			function fullscreen() {
				if (container.requestFullscreen) {
					container.requestFullscreen();
				} else if (container.msRequestFullscreen) {
					container.msRequestFullscreen();
				} else if (container.mozRequestFullScreen) {
					container.mozRequestFullScreen();
				} else if (container.webkitRequestFullscreen) {
					container.webkitRequestFullscreen();
				}
			}
			
			function moverDerecho(distancia) {
				vec.setFromMatrixColumn( camera.matrix, 0 );

				camera.position.addScaledVector( vec, distancia );
			}
			function moverAdelante(distancia) {
				// move forward parallel to the xz-plane
				// assumes camera.up is y-up

				vec.setFromMatrixColumn( camera.matrix, 0 );

				vec.crossVectors( camera.up, vec );

				camera.position.addScaledVector( vec, distancia );
			}
			
			function randomInRange(from, to) {
				var x = Math.random() * (to - from);
				return x + from;
			};
			
			function createCube() {
				var w = randomInRange(20, 500);
				var h = randomInRange(80, 1000);
				var d = w;
				var geometry = new THREE.BoxGeometry(w, h, d);
				var material = new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff});
				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = randomInRange(-2500, 2500);
				cube.position.z = randomInRange(-2500, 2500);
				cube.position.y = h/2;
				objects.push(cube);
			};
			
			function DetectObstaculo(camera){
					var vec = new THREE.Vector3;
					var aux = new THREE.Vector3;
					var axis = new THREE.Vector3(0,1,0);
					var intersections;
					
					camera.getWorldDirection(vec);
					
					raycaster.ray.origin.copy( camera.position );
					raycaster.ray.direction.copy(vec);
					
					intersections = raycaster.intersectObjects( objects );
					if(intersections.length >0)
						moveForward = false;
						
						
					aux = vec.negate();
					raycaster.ray.direction.copy(aux);
		
					intersections = raycaster.intersectObjects( objects );
					if(intersections.length >0)
						moveBackward = false;
						
					
					aux = vec.normalize();
					aux = vec.applyAxisAngle(axis,-Math.PI/2);
					
					raycaster.ray.direction.copy(aux);
					intersections = raycaster.intersectObjects( objects );
					if(intersections.length >0)
						moveLeft = false;
					
					
					aux = vec.normalize();
					aux = vec.applyAxisAngle(axis,Math.PI/2);
					
					raycaster.ray.direction.copy(aux);				
					intersections = raycaster.intersectObjects( objects );
					if(intersections.length >0)
						moveRight = false;
			}
			
			function createMazeCubes2() {
				// Maze wall mapping, assuming even square
				// 1's are cubes, 0's are empty space
				var map = [
				[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, ],
				[1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, ],
				[0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
				[0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ],
				[0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],
				[1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, ],
				[0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, ],
				[0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, ],
				[0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, ],
				[0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, ],
				[0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, ],
				[0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, ],
				[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, ],
				[1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, ],
				[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, ],
				[0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, ],
				[0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, ],
				[0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, ],
				[1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, ],
				[0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, ]
				];
				

				
				// wall details
				var cubeGeo = new THREE.BoxGeometry(UNITWIDTH, UNITHEIGHT, UNITWIDTH);
				var cubeMat = new THREE.MeshPhongMaterial({
								color: 0x81cfe0,
							});

				// Keep cubes within boundry walls
				var widthOffset = UNITWIDTH / 2;
				// Put the bottom of the cube at y = 0
				var heightOffset = UNITHEIGHT / 2;
	
				// See how wide the map is by seeing how long the first array is
				totalCubesWide = map[0].length;

				// Place walls where 1`s are
				for (var i = 0; i < totalCubesWide; i++) {
					for (var j = 0; j < map[i].length; j++) {
						// If a 1 is found, add a cube at the corresponding position
						if (map[i][j]) {
							// Make the cube
							var cube = new THREE.Mesh(cubeGeo, cubeMat);
							// Set the cube position
							cube.position.z = (i - totalCubesWide / 2) * UNITWIDTH + widthOffset;
							cube.position.y = heightOffset;
							cube.position.x = (j - totalCubesWide / 2) * UNITWIDTH + widthOffset;
							// Add the cube
							scene.add(cube);
							// Used later for collision detection
							collidableObjects.push(cube);
							objects.push(cube);
						}
					}
				}
				//-----------------------------------------------------
				//Codigo crear pista
				//-----------------------------------------------------
				/*
				var manager = new THREE.LoadingManager();
				manager.addHandler( /\.dds$/i, new DDSLoader() );
				
				new MTLLoader( manager )
					.setPath( 'examples/models/obj/key/' )
					.load( 'old_key.mtl', function ( materials ) {

						materials.preload();

						 new OBJLoader( manager )
							.setMaterials( materials )
							.setPath( 'examples/models/obj/key/' )
							.load( 'old_key.obj', function ( object ) {
								
								object.scale.x = 0.1;
								object.scale.y = 0.1;
								object.scale.z = 0.1;
								object.position.z = -(totalCubesWide/2)*UNITWIDTH+widthOffset;
								object.position.x = (14- totalCubesWide / 2) * UNITWIDTH + widthOffset;
								object.position.y = 10;
								loader = object;
								
								scene.add( loader);
							

							}, // called when loading is in progresses
							function ( xhr ) {

							console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

							}, 
							function ( error ) {

								console.log( 'An error happened' );

							} );

					} );*/
				
				
				// The size of the maze will be how many cubes wide the array is * the width of a cube
				
				mapSize = totalCubesWide * UNITWIDTH;
				var positionx = -(totalCubesWide/2)*UNITWIDTH+widthOffset;
				var positionz = -(totalCubesWide/2)*UNITWIDTH+widthOffset;
				
				var finalz = (15-totalCubesWide/2)*UNITWIDTH+widthOffset;
				var finalx = (19-totalCubesWide/2)*UNITWIDTH+widthOffset;
				
				mesh.position.set(finalx,20,finalz);
				camera.position.set(positionx,20,positionz);
				
				Reloj.start();
			}
			
			function createMazeCubes() {
				// Maze wall mapping, assuming even square
				// 1's are cubes, 0's are empty space
				var map = [
				[0, 1, 0, 0, 0, 0, 0, 0, 0, 0,  ],
				[0, 0, 0, 1, 1, 0, 1, 1, 1, 0,  ],
				[1, 1, 1, 0, 0, 0, 1, 1, 0, 0,  ],
				[0, 0, 0, 0, 1, 1, 1, 1, 1, 1,  ],
				[0, 1, 1, 1, 0, 0, 0, 0, 0, 0,  ],
				[0, 1, 0, 0, 0, 1, 1, 1, 1, 1,  ],
				[0, 0, 0, 1, 1, 1, 0, 0, 0, 0,  ],
				[0, 0, 0, 1, 1, 1, 1, 1, 1, 0,  ],
				[0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  ],
				[1, 1, 1, 1, 1, 1, 1, 1, 0, 0,  ],
				];
				

				
				// wall details
				var cubeGeo = new THREE.BoxGeometry(UNITWIDTH, UNITHEIGHT, UNITWIDTH);
				var cubeMat = new THREE.MeshPhongMaterial({
								color: 0x81cfe0,
							});

				// Keep cubes within boundry walls
				var widthOffset = UNITWIDTH / 2;
				// Put the bottom of the cube at y = 0
				var heightOffset = UNITHEIGHT / 2;
	
				// See how wide the map is by seeing how long the first array is
				totalCubesWide = map[0].length;

				// Place walls where 1`s are
				for (var i = 0; i < totalCubesWide; i++) {
					for (var j = 0; j < map[i].length; j++) {
						// If a 1 is found, add a cube at the corresponding position
						if (map[i][j]) {
							// Make the cube
							var cube = new THREE.Mesh(cubeGeo, cubeMat);
							// Set the cube position
							cube.position.z = (i - totalCubesWide / 2) * UNITWIDTH + widthOffset;
							cube.position.y = heightOffset;
							cube.position.x = (j - totalCubesWide / 2) * UNITWIDTH + widthOffset;
							// Add the cube
							scene.add(cube);
							// Used later for collision detection
							collidableObjects.push(cube);
							objects.push(cube);
						}
					}
				}
				// The size of the maze will be how many cubes wide the array is * the width of a cube
				
				mapSize = totalCubesWide * UNITWIDTH;
				var positionx = -(totalCubesWide/2)*UNITWIDTH+widthOffset;
				var positionz = -(totalCubesWide/2)*UNITWIDTH+widthOffset;
				
				var finalz = (4-totalCubesWide/2)*UNITWIDTH+widthOffset;
				var finalx = (9-totalCubesWide/2)*UNITWIDTH+widthOffset;
				
				mesh.position.set(finalx,20,finalz);
				camera.position.set(positionx,20,positionz);
				
			}
			
			
			
			function createGround() {
				// Create ground geometry and material
				var groundGeo = new THREE.PlaneGeometry(mapSize, mapSize);
				var groundMat = new THREE.MeshPhongMaterial({ color: 0xA0522D, side: THREE.DoubleSide});

				var ground = new THREE.Mesh(groundGeo, groundMat);
				ground.position.set(0, 1, 0);
				// Rotate the place to ground level
				ground.rotation.x = Math.PI/2
				scene.add(ground);
			}
			
			function createPerimWalls() {
				var halfMap = mapSize / 2;  // Half the size of the map
				var sign = 1;               // Used to make an amount positive or negative

				// Loop through twice, making two perimeter walls at a time
				for (var i = 0; i < 2; i++) {
					var perimGeo = new THREE.PlaneGeometry(mapSize, UNITHEIGHT);
					// Make the material double sided
					var perimMat = new THREE.MeshPhongMaterial({ color: 0x464646, side: THREE.DoubleSide });
					// Make two walls
					var perimWallLR = new THREE.Mesh(perimGeo, perimMat);
					var perimWallFB = new THREE.Mesh(perimGeo, perimMat);

					// Create left/right wall
					perimWallLR.position.set(halfMap * sign, UNITHEIGHT / 2, 0);
					perimWallLR.rotation.y = Math.PI/2;
					scene.add(perimWallLR);
					// Used later for collision detection
					collidableObjects.push(perimWallLR);
					objects.push(perimWallLR);
					// Create front/back wall
					perimWallFB.position.set(0, UNITHEIGHT / 2, halfMap * sign);
					scene.add(perimWallFB);

					// Used later for collision detection
					collidableObjects.push(perimWallFB);
					objects.push(perimWallFB);

					sign = -1; // Swap to negative value
				}
			}
			
			function createtrick(camera){
				var raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3(), 0, 5 );
				var vec = new THREE.Vector3;
				var intersections;
				
				camera.getWorldDirection(vec);
					
				raycaster.ray.origin.copy( camera.position );
				raycaster.ray.direction.copy(vec);
					
				//raycaster.ray.origin.z += 2;
				cubito.position.set(loader.position.x,loader.position.y ,loader.position.z);
					
				intersections = raycaster.intersectObject(cubito);
				if(intersections.length >0)
					console.log('holaa');
			}
			
			//--------------------------------------
			//CÃ³digo para cronometro 
			//--------------------------------------
			
			function cronometrar(){
				escribir();
				id = setInterval(escribir,1000);
				
			}
			function escribir(){
				var hAux, mAux, sAux;
				s++;
				if (s>59){m++;s=0;}
				if (m>59){h++;m=0;}
				if (h>24){h=0;}

				if (s<10){sAux="0"+s;}else{sAux=s;}
				if (m<10){mAux="0"+m;}else{mAux=m;}
				if (h<10){hAux="0"+h;}else{hAux=h;}

				document.getElementById("hms").innerHTML = hAux + ":" + mAux + ":" + sAux; 
			}	
			function parar(){
				clearInterval(id);
			}
			function reiniciar(){
				clearInterval(id);
				document.getElementById("hms").innerHTML="00:00:00";
				h=0;m=0;s=0;
				
			}
			
			function CalculoPuntuacion(){
				
				
				switch(level){
					case 1: 
						break;
					case 2:
						break;
				}
			}
			
			function animate() {

				requestAnimationFrame( animate );
						
					//console.log(camera.position);
					
					DetectObstaculo(camera);
					

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;


					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveRight ) - Number( moveLeft );
					direction.normalize(); // this ensures consistent movements in all directions

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

					
					if(is_mobile){
						moverDerecho(- velocity.x * delta );
						moverAdelante( - velocity.z * delta );
					} else {
						controls.moveRight( - velocity.x * delta );
						controls.moveForward( - velocity.z * delta );
					}
					
					
					prevTime = time;
										
					
					//loader.rotation.y += 0.05;
					
					//-------------------------
					//Cambio al nivel 2 
					//-------------------------
					if((camera.position.x < mesh.position.x+10) && (camera.position.x > mesh.position.x-10) &&
						(camera.position.z < mesh.position.z+10) && (camera.position.z > mesh.position.z-10) && (level === 1))
					{
						// Add the walls(cubes) of the maze
						createMazeCubes2();
						// Add ground plane
						createGround();
						// Add perimeter walls that surround the maze
						createPerimWalls();
						
						level = 2;
						Reloj.stop();
					}
					
					if((camera.position.x < mesh.position.x+10) && (camera.position.x > mesh.position.x-10) &&
						(camera.position.z < mesh.position.z+10) && (camera.position.z > mesh.position.z-10) && (level === 2))
					{
							//fin
					}
					
					
					if(is_mobile){
						effect.render(scene, camera);
						controls.update();
					} else {
						renderer.render(scene, camera);
					}

			}

		</script>
	</body>
</html>
