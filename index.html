<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Prueba para tfg</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			
			
			b {
				color: black
			}
		</style>
	</head>
	<body>
		<div id="example"></div>
		
		<div id="info"> <b>Controles</b> <br/>
		<b>WASD o flechas->mover, </b><b>En ordenador(click)->vista, </b><b>En smartphone(orientaciÃ³n)->vista</b> </div>
			
		<script type="module">

			import * as THREE from '/build/three.module.js';

			import { PointerLockControls } from '/examples/jsm/controls/PointerLockControls.js';
			
			import  FirstPersonVRControls  from '/examples/jsm/controls/FirstPersonVRControls.js';
			
			import { DeviceOrientationControls } from '/examples/jsm/controls/DeviceOrientationControls.js';
  
			import { StereoEffect } from '/examples/jsm/effects/StereoEffect.js';

			var camera, scene, renderer, controls;

			var objects = [];

			var raycaster;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();
			
			var is_mobile= /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
			
			var effect,element,container,cube;
			
			var clock = new THREE.Clock();
			
			var vec = new THREE.Vector3();
			
			var vecPrueba = new THREE.Vector3();
			
			

			init();
			animate();

			function init() {
				
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				//document.body.appendChild( renderer.domElement );
				element = renderer.domElement;
				container = document.getElementById('example');
				container.appendChild(element);
				
				
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 10;
				
				

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );
				scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
				
				

				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );
				
				const rig = new THREE.Object3D();
				rig.add(camera);
				scene.add(rig);
				
				//Controls
				if(is_mobile){
					scene.add(camera);
					
					effect = new StereoEffect(renderer);
			
					controls = new DeviceOrientationControls(camera);
					controls.connect();
					
					

					document.addEventListener( 'click', function () {
						fullscreen();

					}, false );
					
					
					
				} else {
					controls = new PointerLockControls( camera, document.body );
					
					document.addEventListener( 'click', function () {
						
						controls.lock();

					}, false );
					
					scene.add( controls.getObject() );
				}
				
				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;
							
						case 39: // right
						case 68: // d
							moveRight = true;
							break;

	

					}

				};

				var onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3(), 0, 10 );
				 
				// floor

				var material = new THREE.MeshPhongMaterial({
					color: 0xB8B9B9,
				});
				var geometry = new THREE.PlaneGeometry(5000, 5000);

				var mesh = new THREE.Mesh(geometry, material);
				mesh.rotation.x = -Math.PI / 2;
	 
				scene.add(mesh);

				
				for(let i = 1; i <= 150; i++)
					createCube();
    
				objects.forEach((cube) => scene.add(cube));



				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				
				if(is_mobile)
					effect.setSize(width, height);
				
			}
			
			function fullscreen() {
				if (container.requestFullscreen) {
					container.requestFullscreen();
				} else if (container.msRequestFullscreen) {
					container.msRequestFullscreen();
				} else if (container.mozRequestFullScreen) {
					container.mozRequestFullScreen();
				} else if (container.webkitRequestFullscreen) {
					container.webkitRequestFullscreen();
				}
			}
			
			function moverDerecho(distancia) {
				vec.setFromMatrixColumn( camera.matrix, 0 );

				camera.position.addScaledVector( vec, distancia );
			}
			function moverAdelante(distancia) {
				// move forward parallel to the xz-plane
				// assumes camera.up is y-up

				vec.setFromMatrixColumn( camera.matrix, 0 );

				vec.crossVectors( camera.up, vec );

				camera.position.addScaledVector( vec, distancia );
			}
			
			function randomInRange(from, to) {
				var x = Math.random() * (to - from);
				return x + from;
			};
			
			function createCube() {
				var w = randomInRange(20, 500);
				var h = randomInRange(80, 1000);
				var d = w;
				var geometry = new THREE.BoxGeometry(w, h, d);
				var material = new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff});
				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = randomInRange(-2500, 2500);
				cube.position.z = randomInRange(-2500, 2500);
				cube.position.y = h/2;
				objects.push(cube);
			};
			
			function DetectObstaculo(camera){
					var vec = new THREE.Vector3;
					var aux = new THREE.Vector3;
					var axis = new THREE.Vector3(0,1,0);
					var intersections;
					
					camera.getWorldDirection(vec);
					
					raycaster.ray.origin.copy( camera.position );
					raycaster.ray.direction.copy(vec);
					
					//raycaster.ray.origin.z += 2;
					
					intersections = raycaster.intersectObjects( objects );
					if(intersections.length >0)
						moveForward = false;
						
					aux = vec.negate();
					raycaster.ray.direction.copy(aux);
					
					//raycaster.ray.origin.z -= 2;
					
					intersections = raycaster.intersectObjects( objects );
					if(intersections.length >0)
						moveBackward = false;
						
					aux = vec.normalize();
					aux = vec.applyAxisAngle(axis,-Math.PI/2);
					
					raycaster.ray.direction.copy(aux);
					
					//raycaster.ray.origin.x -= 2;
					intersections = raycaster.intersectObjects( objects );
					if(intersections.length >0)
						moveLeft = false;
					
					aux = vec.normalize();
					aux = vec.applyAxisAngle(axis,Math.PI/2);
					
					raycaster.ray.direction.copy(aux);
					
					//raycaster.ray.origin.x += 2;
					intersections = raycaster.intersectObjects( objects );
					if(intersections.length >0)
						moveRight = false;
			}
			
			function animate() {

				requestAnimationFrame( animate );
						
					
					
					DetectObstaculo(camera);

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;


					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveRight ) - Number( moveLeft );
					direction.normalize(); // this ensures consistent movements in all directions

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

					
					if(is_mobile){
						moverDerecho(- velocity.x * delta );
						moverAdelante( - velocity.z * delta );
					} else {
						controls.moveRight( - velocity.x * delta );
						controls.moveForward( - velocity.z * delta );
					}
					

					prevTime = time;
					
					if(is_mobile){
						effect.render(scene, camera);
						controls.update();
					} else {
						renderer.render(scene, camera);
					}

			}

		</script>
	</body>
</html>
